// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package foobar

import "sync"

type Result struct {
	Key    *Baz
	Values []Bar
}

func MapOneBazToManyBar(these []Baz, do func(Baz) ([]Bar, error)) (map[*Baz][]Bar, []error) {
	pool := make(map[*Baz][]Bar, 0)
	errs := make([]error, 0)

	if len(these) > 0 {
		var wg sync.WaitGroup

		wg.Add(len(these))

		poolCh := make(chan Result, len(these))
		errsCh := make(chan error, len(these))
		for _, this := range these {
			go func(this Baz) {
				defer wg.Done()

				t, e := do(this)
				if e != nil {
					errsCh <- e
				} else {
					poolCh <- Result{
						Key:    &this,
						Values: t,
					}
				}
			}(this)
		}

		wg.Wait()

		for _ = range these {
			select {
			case this := <-poolCh:
				pool[this.Key] = this.Values
			case err := <-errsCh:
				errs = append(errs, err)
			}
		}
	}

	return pool, errs
}
